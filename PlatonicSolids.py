import copy

def finishProb(shape,sides,borders):
    #shape: an adjacency list of which sides are connected for the solid being considered
    #sides: a list of the faces of the polyhedron included in the 2D shape we're looking at right now
    #borders: a list of the available edges that we can attach new shapes to.  Each edge is a 2-coordinate tuple,
    #where the first coordinate is the face number, ranging from 0 to (# of faces)-1,
    #and the second coordinate is the border number, ranging from 0 to (# of edges on a face)-1

    #If we've finished constructing our solid, return a probability of 1
    if len(sides)==len(shape):
        allProbs[(tuple(sides),tuple(borders))]=1
        return 1
    else:
        prob=0
        #try to add a face in every position around the border
        for i in borders:
            newSide=shape[i[0]][i[1]]
            #if our new face doesn't overlap with an existing face when we fold it
            if newSide not in sides:
                #add our new face to our list of faces
                newSides=copy.deepcopy(sides)
                newSides.append(newSide)
                #modify our list of borders, adding the borders of the new face, and removing the border we glued it to
                newBorders=copy.deepcopy(borders)
                newBorders.remove(i)
                for j in range(len(shape[newSide])):
                    if shape[newSide][j]!=i[0]:
                        newBorders.append((newSide,j))

                #Check if we've analyzed this shape already.
                #If so, factor in the probability we already found.
                #If not, recursively call finishProb to find the probability of the new shape producing the full solid.
                newSides.sort()
                newBorders.sort()
                if (tuple(newSides),tuple(newBorders)) in allProbs:
                    prob+=allProbs[tuple(newSides),tuple(newBorders)]/len(borders)
                else:
                    prob+=finishProb(shape,newSides,newBorders)/len(borders)
        #if len(sides)<10:
        #    print(len(sides),prob,sides,borders)
        allProbs[(tuple(sides),tuple(borders))]=prob
        return prob

allProbs={}

#Adjacency lists for each of the solids (generated by subtracting 1 from all the faces of a set of D&D dice)
tetrahedron=[[1,2,3],[0,3,2],[0,1,3],[0,2,1]]
cube=[[1,3,4,2],[0,2,5,3],[0,4,5,1],[0,1,5,4],[0,3,5,2],[1,2,4,3]]
octahedron=[[2,6,3],[7,2,3],[0,1,4],[0,5,1],[2,7,6],[3,6,7],[0,4,5],[1,5,4]]
dodecahedron=[[1,3,5,4,9],[0,9,6,7,3],[3,7,11,10,5],[0,1,7,2,5],[0,5,10,8,9],[0,3,2,10,4],[1,9,8,11,7],[1,6,11,2,3],[4,10,11,6,9],[0,4,8,6,1],[2,11,8,4,5],[2,7,6,8,10]]
icosahedron=[[6,18,12],[11,17,19],[15,18,16],[10,13,17],[12,17,14],[8,15,13],[0,14,16],[9,19,15],[5,10,18],[7,16,11],[3,12,8],[1,9,14],[0,10,4],[3,5,19],[4,11,6],[2,7,5],[2,6,9],[1,4,3],[0,2,8],[1,13,7]]

#Running the program for each solid.  For solids with triangles as faces, we can start with 3 adjacent triangles.
#For the cube and dodecahedron, we can start with 2 adjacent faces.

#print(finishProb(tetrahedron,[0,1],[(0,1),(0,2),(1,1),(1,2)]))
#print(finishProb(cube,[0,1],[(0,1),(0,2),(0,3),(1,1),(1,2),(1,3)]))
#print(finishProb(octahedron,[0,1,2],[(0,1),(0,2),(1,0),(1,2),(2,2)]))
#print(finishProb(dodecahedron,[0,1],[(0,1),(0,2),(0,3),(0,4),(1,1),(1,2),(1,3),(1,4)]))
#print(finishProb(icosahedron,[0,6,12],[(0,1),(0,2),(6,1),(6,2),(12,1),(12,2)]))